@title("Silk Format Specification")

[index.html UTGB Toolkit Index]

= Silk Text Format Specification

This document is written by Taro L. Saito.

* Introduction
** [#WhatisSilk What is Silk?]
** [#SilkFeatures Silk Features]
** [#SilkDataModel Silk Data Model]
** [#SituationswhereSilkisuseful Situations where Silk is useful]
** [#SituationswhereSilkisnotuseful Situations where Silk is not useful]
* Silk Data Descriptions
** [#Preamble Preamble]
** [#Commentline Comment Line]
** [#Treenodewithatextvalue Tree node with a text value]
** [#Treenodewithseveralchildnodeswithtextvalues Tree node with several child nodes with text values]
** [#Nestedtreendoes Nested tree nodes]
** [#Tabseparateddata Tab-separated data]
** [#Multilinetextvalues Multi-line text values]
** [#Importanotherfile Import another file]
** [#InlineJSONdataArray In-line JSON array]
** [#InlineJSONdataObject In-line JSON object]
** [#CommaseparatedvaluesCSV Comma-separated values: CSV]

* Silk Examples
** 

== What is Silk? 

{b|Silk} is a human-friendly and space-efficient text format, desigined for describing tree-structured data. Silk is a replacement XML and JSON, which are well-known tree-structured data formats. Silk format does not use tags or brackets to organize tree-structures. Instead, indentation via spaces represents data hierarachies, which is far simpler than neately opening and closing maching tags (or brackets). Silk is {b|tree-compatible with XML and JSON}; if XML or JSON data have a data model in which each tree node has at most one text value, these XML or JSON data can be automatically translated into Silk format (For the precise definition of tree-compatibility, see [#TreeCompatible this documentation]). The reverse direction is much easier; Silk format can be easily converted into XML or JSON in stream fashion. Therefore, you can utilize existing XML or JSON processors to analyze your data writtin in Silk format. 



== Silk Features
Silk text format has the following features:
* {b|Tree Compatible}
** Silk is has a [#SilkDataModel tree-structured data model], which is [#TreeCompatible tree-compatible] with XML and JSON data format.
* {b|Human-friendly format}
** In Silk, indentation with spaces is used for nesting data structures, so no need exists to wrap text data with tags. In addition, you can omit double quotations to describe text data, which are mandatory in JSON.
* {b|Space-efficient format}
** Tab-separated format or comma-separated values (CSV) can be embedded in Silk at any hierarhical position. XML and JSON have no support for such compact data formats.
* {b|Import function}
** Several data files (e.g. another Silk file, tab-seaparted data, CSV, text or binary files, etc.) can be imported into a Silk file to compose a large data set.
* {b|One-liner format}
** Silk data can be processed line-by-line, so it is very familiar with standard text-processing tools, such as grep, awk, Perl, Ruby, etc.

== Silk Data Model

Data model that can be described with Silk format is a {b|forest}, that is, a list of {b|trees} consisting of nodes. Each tree node can have several child nodes and a text value. 

(needs some illustration)

== Situations where Silk is useful 

Silk format has no need to close tags or quotations. This feature is suitable for data logging, which needs to incrementally append data to the end of a file. Silk is also useful for accumulating large program outputs. One of the design goals of Silk is to provide a compact representation of biological data. If you do not like verbose data descriptions of XML or JSON formats, Silk will match your needs. Under several years of experiences of processing XML and JSON format under our belt, we simplified these syntaxes by removing unnecessary symbols, such as tags or brackets. Embedded tab-separated data description in Silk significantly reduces the data size. 

Silk also can be used to enhance existing tab-separated data or comma-separated value (CSV) files with node labels and structures. These flat files can be imported into a Silk file, and you can annotate each data with node labels, and also can organize them in a hierarchical data structure. 

== Situations where Silk is not useful

Silk is not a markup language such as HTML, so it doesn't suit to represent text decorations. For example, the following text data description, which mixes text values and tags cannot be desribed with Silk:
<code>
<p>This paragraph contains <b>bold</b> and <i>italic</i> fonts.
</code>

This is because Silk's data model allows only one text value for each tree node. However, this limitation does not mean Silk cannot describe HTML data. If necessary, you can embed HTML data as a text value. Here is an example:
<code>
-p: This paragraph contains <b>bold</b> and <i>italic</i> fonts.
</code>
or you can use double quotation to embed arbitrary text.
<code>
-p:"This paragraph contains <b>bold</b> and <i>italic</i> fonts."</code>

== Tree Compatibility

(To be written)

= Silk Data Descriptions

== Preamble

Preamble beginning with '%' symbol specifies version or encoding of Silk text file. This line should be placed in the first line of Silk files in order to correctly change the behaviour of the Silk processor according to the specified character encoding. Preamble description can be ommitted, and the default encoding is utf-8.

=== Version information
<code>
% silk(version:1.0)
</code>

=== Encoding
<code>
% silk(version:1.0, encoding:utf-8)
</code>

== Comment line

Comment line is preceded by a sharp '#':

<code>
# This line will be ignored.
</code>

== Tree node with a text value
Tree nodes begin with a hyphen '-' followed by a node name. The text value of the node follows a colon ':'. If the colon and text value are not present, the node value of the tree node will be set to null:
{b|Silk}
<code>
- title: hello world
</code>

White spaces around text values will be ignored.

{b|JSON}
<code>
{ "title":"hello world" }
</code>

== Tree node with several child nodes with text values
{b|Silk}
<code>
- book(id:1, title: Database Management Systems, isbn:0071230572, year:2002)
</code>

{b|JSON}
<code>
{
 "book":
  {
   "id":1, 
   "title":"Database Management Systems", 
   "isbn":"0071230572", 
   "year":2002
  }
}
</code>

== Nested tree nodes

Indentation before hyphen ('-') represents tree node depth. Only space characters (' ') are allowed before the indentation hyphen ('-'). Tab character ('\t') cannot be used for indentations.

{b|Silk}
<code>
- book
 - id: 1
 - title: Database Management Systems
 - isbn:0071230572
 - year:2002
- book		
 - id: 2
 - title: Compilers: Second Edition
 - isbn:0321547985
 - year:2007
</code>

Alternatively, you can write the same data as follows:
<code>
- book(id:1, title: Database Management Systems, isbn:0071230572, year:2002)
- book(id:2, title: Compilers: Second Edition, isbn:0321547985, year:2007)
</code>


{b|JSON}
<code>
[
 {"book":
  {
   "id":1, 
   "title":"Database Management Systems", 
   "isbn":"0071230572", 
   "year":2002
  }
 },
 {"book":
  {
   "id":2, 
   "title":"Compilers: Second Edition",
   "isbn":"03215479785", 
   "year":2007
  }
 }
]
</code>

{b|XML}
<code>
<book>
 <id>1</id>
 <title>Database Management Systems</title>
 <isbn>0071230572</isbn>
 <year>2002</year>
</book>
<book>
 <id>2</id>
 <title>Compilers: Second Edition</title>
 <isbn>0321547985</isbn>
 <year>2007</year>
</book>
</code>

== Tab-separated data 

The design concept of Silk format is to reduce the redandancy of XML or JSON data format in describing large data set. If node description ends with a bar '|', following lines are splitted by tabs, and each text component separated by tabs is assigned a corresponding node name. The node name of each tab-separated data can be specified in the preceding child node descriptions:
{b|Silk}
<pre>
# A book node schema with 4 parameters. 
-book(id, title, isbn, year)|
1	Database Management Systems	0071230572	2002
2	Compilers: Second Edition	0321547985	2007

# Tab-separated data region ends when a new node is found
-updated: 2009/02/16
</pre>

{b|JSON}
<code>
{
 "book":[
   {
     "id":1, 
     "title":"Database Management Systems", 
     "isbn":"0071230572", 
     "year":2002
   },
   {
     "id":2, 
     "title":"Compilers: Second Edition",
     "isbn":"0321547985", 
     "year":2007
   }
 ],
 "updated":"2009/02/16"
}
</code>

{b|XML}
<code>
<book>
 <id>1</id>
 <title>Database Management Systems</title>
 <isbn>0071230572</isbn>
 <year>2002</year>
</book>
<book>
 <id>2</id>
 <title>Compilers: Second Edition</title>
 <isbn>0321547985</isbn>
 <year>2007</year>
</book>
<updated>2009/02/16</updated>
</code>


== Multi-line text values

Large text values can be split into multiple lines. To describe muti-line text values, use "'>'" symbol instead of ':' (colon). The following examples shows a gene sequence of NM_001005277:

{b|Silk}
<code>
-gene(name:NM_001005277)
 -sequence>
ATGGATGGAGAGAATCACTCAGTGGTATCTGAGTTTTTGTTTCTGGGACTCACTCATTCATGGGAGATCC
AGCTCCTCCTCCTAGTGTTTTCCTCTGTGCTCTATGTGGCAAGCATTACTGGAAACATCCTCATTGTGTT
TTCTGTGACCACTGACCCTCACTTACACTCCCCCATGTACTTTCTACTGGCCAGTCTCTCCTTCATTGAC
TTAGGAGCCTGCTCTGTCACTTCTCCCAAGATGATTTATGACCTGTTCAGAAAGCGCAAAGTCATCTCCT
TTGGAGGCTGCATCGCTCAAATCTTCTTCATCCACGTCGTTGGTGGTGTGGAGATGGTGCTGCTCATAGC
CATGGCCTTTGACAGATATGTGGCCCTATGTAAGCCCCTCCACTATCTGACCATTATGAGCCCAAGAATG
TGCCTTTCATTTCTGGCTGTTGCCTGGACCCTTGGTGTCAGTCACTCCCTGTTCCAACTGGCATTTCTTG
TTAATTTAGCCTTCTGTGGCCCTAATGTGTTGGACAGCTTCTACTGTGACCTTCCTCGGCTTCTCAGACT
AGCCTGTACCGACACCTACAGATTGCAGTTCATGGTCACTGTTAACAGTGGGTTTATCTGTGTGGGTACT
TTCTTCATACTTCTAATCTCCTACGTCTTCATCCTGTTTACTGTTTGGAAACATTCCTCAGGTGGTTCAT
CCAAGGCCCTTTCCACTCTTTCAGCTCACAGCACAGTGGTCCTTTTGTTCTTTGGTCCACCCATGTTTGT
GTATACACGGCCACACCCTAATTCACAGATGGACAAGTTTCTGGCTATTTTTGATGCAGTTCTCACTCCT
TTTCTGAATCCAGTTGTCTATACATTCAGGAATAAGGAGATGAAGGCAGCAATAAAGAGAGTATGCAAAC
AGCTAGTGATTTACAAGAGGATCTCATAA
</code>

Multi-line text values in Silk are connected into a single string. Leading white spaces and tail white spaces (including new line chracters "\r" and "\n") of each text line will be trimmed down.

{b|JSON}
<code>
{"gene":
 {"name":"NM_001005277",
  "sequence":"ATGGATGGAGAGAATCACTCAGTGGTATCTGAGTTTTTGTTTCTGGGACTCACTCATTCATGGGAGATCCAGCTCCTCCTCCTAGTGTTTTCCTCTGTGCTCTATGTGGCAAGCATTACTGGAAACATCCTCATTGTGTTTTCTGTGACCACTGACCCTCACTTACACTCCCCCATGTACTTTCTACTGGCCAGTCTCTCCTTCATTGACTTAGGAGCCTGCTCTGTCACTTCTCCCAAGATGATTTATGACCTGTTCAGAAAGCGCAAAGTCATCTCCTTTGGAGGCTGCATCGCTCAAATCTTCTTCATCCACGTCGTTGGTGGTGTGGAGATGGTGCTGCTCATAGCCATGGCCTTTGACAGATATGTGGCCCTATGTAAGCCCCTCCACTATCTGACCATTATGAGCCCAAGAATGTGCCTTTCATTTCTGGCTGTTGCCTGGACCCTTGGTGTCAGTCACTCCCTGTTCCAACTGGCATTTCTTGTTAATTTAGCCTTCTGTGGCCCTAATGTGTTGGACAGCTTCTACTGTGACCTTCCTCGGCTTCTCAGACTAGCCTGTACCGACACCTACAGATTGCAGTTCATGGTCACTGTTAACAGTGGGTTTATCTGTGTGGGTACTTTCTTCATACTTCTAATCTCCTACGTCTTCATCCTGTTTACTGTTTGGAAACATTCCTCAGGTGGTTCATCCAAGGCCCTTTCCACTCTTTCAGCTCACAGCACAGTGGTCCTTTTGTTCTTTGGTCCACCCATGTTTGTGTATACACGGCCACACCCTAATTCACAGATGGACAAGTTTCTGGCTATTTTTGATGCAGTTCTCACTCCTTTTCTGAATCCAGTTGTCTATACATTCAGGAATAAGGAGATGAAGGCAGCAATAAAGAGAGTATGCAAACAGCTAGTGATTTACAAGAGGATCTCATAA"}}
</code>

== Import another file

Silk format has a built-in support of import function, which is useful for annotating existing data files (e.g., tab-separated data) with Silk. The following examples loads tab-separated data from another file, and associated each tab-separated data with node names:

<code>
- book(id, title, isbn, year)|
@import(book.tab) 
</code>

book.tab
<pre>
1	Database Management Systems	0071230572	2002
2	Compilers: Second Edition	0321547985	2007
</pre>

The above data using two files are equivalent to the following Silk file:
<pre>
- book(id, title, isbn, year)|
1	Database Management Systems	0071230572	2002
2	Compilers: Second Edition	0321547985	2007
</pre>


Binary files also can be imported as a node value:
<code>
- photo
 - title: vacation
 - image: @import(myphoto.jpg)	# import myphoto.jpg as a node value (encoded with base64)
 - categories: holiday family
</code>

== In-line JSON data (Array)

JSON data can be embedded as a text value by specifying data type description "[json]" after the node name.

{b|Silk}
<code>
 -prime[json]: [2, 3, 5, 7, 11, 13, 17, 19, 23]
</code>

{b|JSON}
<code>
{"prime":[2, 3, 5, 7, 11, 13, 17, 19, 23]}
</code>

{b|XML}
<code>
<prime>2</prime>
<prime>3</prime>
<prime>5</prime>
<prime>7</prime>
<prime>11</prime>
<prime>13</prime>
<prime>17</prime>
<prime>19</prime>
<prime>23</prime>
</code>

== In-line JSON data (Object)

When you have to describe several parameter values for each node, but appearance of these parameters may varies, you can use in-line json object description. 

{b|Silk}
<code>
-book(id, title, isbn, year, _[json])|
1	Database Management Systems	0071230572	2002	{"star":5, "comment":"good book"}
2	Compilers: Second Edition	0321547985	2007	{"tags":["read later", "textbook"]}
</code>
If the node name is '_' (underscore), each component of the in-line json data is treated as a direct child node of the parent node (book node in the above example). 

{b|JSON}
<code>
{
 "book":[
   {
     "id":1, 
     "title":"Database Management Systems", 
     "isbn":"0071230572", 
     "year":2002,
     "star":5,
     "comment":"good book"
   },
   {
     "id":2, 
     "title":"Compilers: Second Edition",
     "isbn":"0321547985", 
     "year":2007,
     "tags":["read later", "textbook"]
   }
 ]
}
</code>


You can wrap the in-line json data within a named node:

{b|Silk}
<code>
-book(id, title, isbn, year, param[json])|
1	Database Management Systems	0071230572	2002	{"star":5, "comment":"good book"}
2	Compilers: Second Edition	0321547985	2007	{"tags":["read later", "textbook"]}
</code>


{b|JSON}
<code>
{
 "book":[
   {
     "id":1, 
     "title":"Database Management Systems", 
     "isbn":"0071230572", 
     "year":2002,
     "param":{"star":5, "comment":"good book"}
   },
   {
     "id":2, 
     "title":"Compilers: Second Edition",
     "isbn":"0321547985", 
     "year":2007,
     "param":{"tags":["read later", "textbook"]}
   }
 ]
}
</code>

== Comma-separated values (CSV)

{b|Silk} (single line, using json array)
<code>
-prime[json]: [2, 3, 5, 7, 11, 13, 17, 19, 23]
</code>

{b|Silk} (multi lines)
<code>
-prime*
 2,  3,  5
 7, 11, 13
17, 19, 23
</code>


{b|JSON}
<code>
{"prime":[2, 3, 5, 7, 11, 13, 17, 19, 23]}
</code>

{b|XML}
<code>
<prime>2</prime>
<prime>3</prime>
<prime>5</prime>
<prime>7</prime>
<prime>11</prime>
<prime>13</prime>
<prime>17</prime>
<prime>19</prime>
<prime>23</prime>
</code>


= Silk Examples



/*

<pre>
% silk(version:1.0)
# single comment line

# object data (object_name(attribute1[:value], ...))
- track(name:"refseq gene")
 - author: leo	     # author is a child node of the track node

# specify coordinates 
- coordinate(group:utgb, name:chr1, species:human, revision:hg18)
# gene data description with tab-seaprated data format
 - gene(name, strand, start, end, cds(start, end), exon(start, end)*)|
NM_001005277	+	357521	358460	[357521, 358460]	[[357521, 358460]]
NM_001005224	+	357521	358460	[357521, 358460]	[[357521, 358460]]
NM_001005221	+	357521	358460	[357521, 358460]	[[357521, 358460]]
NM_001005277	-	610958	611897	[610958, 611897]	[[610958, 611897]]
NM_001005224	-	610958	611897	[610958, 611897]	[[610958, 611897]]
NM_001005221	-	610958	611897	[610958, 611897]	[[610958, 611897]]
NM_152486	+	850983	869824	[851184, 869396]	[[850983, 851043],[851164, 851256],[855397, 855579]] 

# indentation before tab-separated data can be used for readability
- coordinate(group:utgb, name:chr2, species:human, revision:hg18)
 - gene(name, strand, start, end, cds(start, end), exon(start, end)*)|
   NM_001005277	+	357521	358460	[357521, 358460]	[[357521, 358460]]
   NM_001005278	+	357521	358460	[357521, 358460]	[[357521, 358460]]
  
# flexible structure organization 
- coordinate(group:utgb, species:human, revision:hg18)
 - gene(coordinate.name, name, strand, start, end)| # coordinate names is pulled down from the parent node
chr1	gene1	+	357521	358460
chr2	gene2	+	357521	358460
chr10	gene3	+	357521	358460
chr3	gene4	+	357521	358460
chr1	gene5	+	357521	358460

</pre>
*/