@title("Silk Format Specification")

[index.html UTGB Toolkit Index]

= Silk Format Specification

This document is written by Taro L. Saito.

* Introduction
** [#WhatIsSilk What is Silk]
** [#SilkFeatures Silk Features]
** [#SilkDataModel Silk Data Model]
** [#WhatSilkisfor What Silk is for?]
** [#WhatSilkisNOTfor What Silk is NOT for?]
* Silk Data Descriptions
** [#Commentline Comment Line]
** [#Treenodewithatextvalue Tree node with a text value]
** [#Treenodewithseveralchildnodeswithtextvalues Tree node with several child nodes with text values]
** [#Nestedtreendoes Nested tree nodes]
** [#Tabseparateddata Tab-separated data]


== What is Silk? 

{b|Silk} is a human-friendly and space-efficient text format, desigined for describing tree-structured data. Silk is a replacement of well-known tree-structured data format, such as XML, JSON. Silk is easier to describe tree-structured data, since there is no need to wrap data with tags for describing data hierarchies. Instead indentation via spaces represents data hierarachies. Silk is {b|tree-compatible with XML and JSON}; what can be described in XML or JSON can be automatically translated into Silk, and similarly Silk can be converted into XML or JSON. For the definition of tree-compatibility, see [#TreeCompatible this documentation].

== Silk Features
Silk text format has the following features:
* {b|Tree Compatible}
** Silk is has a [#SilkDataModel tree-structured data model], which is [#TreeCompatible tree-compatible] with XML and JSON data format.
* {b|Human-friendly format}
** In Silk, indentation with spaces is used for data nesting, so no need exists to wrap text data with tags. In most cases, you can also omit double quotations to describe text data. 
* {b|Space efficient}
** Tab-separated format or comma-separated values (CSV) can be embedded in Silk at any hierarhical position. XML and JSON have no support for such compact data formats.
* {b|Import function}
** Several data files (e.g. another Silk file, tab-seaparted data, CSV, text or binary files, etc.) can be imported into a Silk file to compose a large data set.
* {b|One-liner format}
** Silk data can be processed line-by-line, so it is very familiar with standard text-processing tools, such as grep, awk, Perl, Ruby, etc.
 

== Silk Data Model

Data model that can be described with Silk format is a {b|forest}, that is, a list of {b|trees} consisting of nodes. Each tree node can have several child nodes. Each tree node in Silk can have a text value.

== What Silk is for?

Silk format has no need to close tags or quotations. This feature is prefarrable for data logging, which incrementally appends data to the end of a file, and also for accumulating program outputs. If you hate verbose data description of XML and JSON, Silk might satisfy your needs, because embedded tab-separated data description significantly reduces the data size compared to XML and JSON.

== What Silk is NOT for? 

Silk is not a markup language such as HTML, so it doesn't suit to represent text decorations. For example, the following text data description, which mixes text values and tags cannot be desribed with Silk:
<code>
<p>This paragraph contains <b>bold</b> and <i>italic</i> fonts.
</code>

This is because Silk's data model allows only one text value for each tree node. However, this limitation does not mean Silk cannot describe HTML data. If necessary, you can embed HTML data as a text value in Silk. Here is some examples:
<code>
-p: This paragraph contains <b>bold</b> and <i>italic</i> fonts.
</code>
or
<code>
-p:"This paragraph contains <b>bold</b> and <i>italic</i> fonts."</code>

== Tree Compatibility

(To be written)

= Silk Data Descriptions

== Comment line

Comment line is preceded by a sharp '#':

<code>
# This line will be ignored.
</code>

== Tree node with a text value
Tree nodes begin with a slash '-' followed by a node name. Text values can be followed after a comma ','. If comma and text value are not present, its node value will be set to null:
{b|Silk}
<code>
- title: hello world
</code>

White spaces around text values will be ignored.

{b|JSON}
<code>
{ "title":"hello world" }
</code>

== Tree node with several child nodes with text values
{b|Silk}
<code>
- book(id:1, title: Database Management Systems, isbn:0071230572, year:2002)
</code>

{b|JSON}
<code>
{
 "book":
  {
   "id":1, 
   "title":"Database Management Systems", 
   "isbn":0071230572, 
   "year":2002
  }
}
</code>

== Nested tree nodes

Indentation before slash represents tree node depth. Only spaces (' ') are allowed before slash ('-'). Tab character ('\t') cannot be used for indentation.

<code>
- book
 - id: 1
 - title: Database Management Systems
 - isbn:0071230572
 - year:2002
</code>

{b|JSON}
<code>
{
 "book":
  {
   "id":1, 
   "title":"Database Management Systems", 
   "isbn":0071230572, 
   "year":2002
  }
}
</code>

== Tab-separated data 

The design concept of Silk format is to reduce redandancy of XML or text data format in describing large data set. If node description ends with a bar '|', following lines are splitted by tabs, and each text component is assigned a corresponding node name. Node name of each tab-separated data can be specified in the preceding child node descriptions:
{b|Silk}
<code>
-book(id, title, isbn, year)|
1	"Database Management Systems"	0071230572	2002
2	"Compilers Principles, Techniques & Tools"	0321547985	2007
</code>

{b|JSON}
<code>
{
 "book":[
   {
     "id":1, 
     "title":"Database Management Systems", 
     "isbn":0071230572, 
     "year":2002
   },
   {
     "id":2, 
     "title":"Compilers Principeles, Techniques & Tools",
     "isbn":0321547985, 
     "year":2007
   }
 ]
}
</code>

{b|XML}
<code>
<book>
 <id>1</id>
 <title>Database Management Systems</title>
 <isbn>0071230572</isbn>
 <year>2002</year>
</book>
<book>
 <id>2</id>
 <title>Compilers Principeles, Techniques &amp; Tools</title>
 <isbn>0321547985</isbn>
 <year>2007</year>
</book>
</code>



== Preamble

Preamble specifies version of Silk format. 
<code>
% silk(version:1.0)
</code>

= Silk Example
<code>
% silk(version:1.0)
# single comment line

# object data (object_name(attribute1[:value], ...))
- track(name:"refseq gene")
# specify coordinates 
- coordinate(group:utgb, type:chromosome, species:human, revision:hg18)
# chromosome 1 scope begin
 - coordinate.name:chr1
 - gene(name, strand, start, end, cds(start, end), exon(start, end))|
NM_001005277	+	357521	358460	[357521, 358460]	[[357521, 358460]]
NM_001005224	+	357521	358460	[357521, 358460]	[[357521, 358460]]
NM_001005221	+	357521	358460	[357521, 358460]	[[357521, 358460]]
NM_001005277	-	610958	611897	[610958, 611897]	[[610958, 611897]]
NM_001005224	-	610958	611897	[610958, 611897]	[[610958, 611897]]
NM_001005221	-	610958	611897	[610958, 611897]	[[610958, 611897]]
NM_152486	+	850983	869824	[851184, 869396]	[[850983, 851043],[851164, 851256],[855397, 855579]]

# chromosome 1 scope end
# chromosome 2 scope begin
- coordinate.name:chr2
 - gene(name, strand, start, end, cds(start, end), exon(start, end))|
NM_001005277	+	357521	358460	[357521, 358460]	[[357521, 358460]]

# chromosome 2 scope end
  
# flexible relation description
- coordinate(group:utgb, type:chromosome, species:human, revision:hg18)
 - gene(coordinate.name, name, strand, start, end)|
chr1	gene1	+	357521	358460
chr2	gene2	+	357521	358460
chr10	gene3	+	357521	358460
chr3	gene4	+	357521	358460
chr1	gene5	+	357521	358460

</code>
